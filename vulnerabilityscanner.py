#!/usr/bin/env python3
"""
Network Vulnerability Scanner for Parrot OS

Features:
1. Validates the target (IP or hostname).
2. Scans the target network to identify active devices, open ports, and running services.
3. Checks detected service versions against known vulnerabilities using the CIRCL CVE API.
4. Prints the scan results and vulnerabilities immediately after the scan.
5. Monitors real-time network traffic using Scapy (optional).
6. Ensures required dependencies are installed in a virtual environment.
7. Outputs results as structured JSON to a file.
"""

import sys
import os
import socket
import subprocess
import json
from datetime import datetime
import importlib.util

# --- Dependency Management ---
REQUIRED_PACKAGES = {
    "requests": "requests",
    "python-nmap": "nmap",
    "scapy": "scapy.all"
}

def install_and_import(pkg_name, mod_name=None):
    """
    Attempt to import a module. If missing, install the package and try again.
    """
    mod_name = mod_name or pkg_name
    try:
        return importlib.import_module(mod_name)
    except ImportError:
        print(f"[INFO] Module '{mod_name}' not found. Installing package '{pkg_name}'...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", pkg_name])
        return importlib.import_module(mod_name)

def check_virtualenv():
    """
    Advise the user if the script is not running in a virtual environment.
    """
    if sys.prefix == sys.base_prefix:
        print("[WARNING] It is highly recommended to run this script within a virtual environment for better dependency management.")

# Dynamically import required modules
requests = install_and_import("requests")
nmap = install_and_import("python-nmap", "nmap")
scapy_all = install_and_import("scapy", "scapy.all")
from scapy.all import sniff, IP

# --- Core Functionality ---

def validate_target(target: str) -> bool:
    """
    Validate that the provided target (IP or hostname) resolves.
    """
    try:
        socket.gethostbyname(target)
        return True
    except socket.error:
        return False

def scan_network(target: str) -> list:
    """
    Perform an nmap scan on the target using service/version detection.
    Return a list of discovered hosts along with their open ports and service details.
    """
    scanner = nmap.PortScanner()
    print(f"[INFO] Scanning target: {target} ...")
    try:
        scanner.scan(target, arguments="-sV")
    except Exception as e:
        print(f"[ERROR] Scanning failed for target {target}: {e}")
        return []
    
    devices = []
    for host in scanner.all_hosts():
        host_info = {
            "ip": host,
            "hostname": scanner[host].hostname(),
            "state": scanner[host].state(),
            "open_ports": []
        }
        for protocol in scanner[host].all_protocols():
            for port in scanner[host][protocol]:
                port_details = scanner[host][protocol][port]
                host_info["open_ports"].append({
                    "port": port,
                    "protocol": protocol,
                    "service": port_details.get("name", ""),
                    "version": port_details.get("version", "")
                })
        devices.append(host_info)
    
    # Print scan results immediately
    print("\n[INFO] Scan Results:")
    print(json.dumps(devices, indent=4))
    return devices

def query_cve(service: str, version: str) -> list:
    """
    Query the CIRCL CVE API for a given service and version.
    Returns a list of vulnerabilities (if any) including CVE IDs and summaries.
    """
    base_url = "https://cve.circl.lu/api/search"
    url = f"{base_url}/{service}/{version}"
    try:
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            data = response.json()
            results = data.get("results", [])
            vulns = []
            for item in results:
                vulns.append({
                    "cve_id": item.get("id", "N/A"),
                    "description": item.get("summary", "No description available.")
                })
            return vulns
        else:
            print(f"[INFO] No vulnerability data for {service} version {version} (HTTP {response.status_code}).")
            return []
    except Exception as e:
        print(f"[ERROR] CVE query failed for {service} version {version}: {e}")
        return []

def check_vulnerabilities(devices: list) -> list:
    """
    For each open port on every discovered device, check for known vulnerabilities.
    Returns a consolidated list of vulnerability findings.
    """
    vulnerabilities = []
    for device in devices:
        for port in device.get("open_ports", []):
            service = port.get("service")
            version = port.get("version")
            if service and version:
                vulns = query_cve(service, version)
                for vuln in vulns:
                    vulnerabilities.append({
                        "device_ip": device["ip"],
                        "service": service,
                        "version": version,
                        "cve_id": vuln["cve_id"],
                        "description": vuln["description"]
                    })
    
    # Print vulnerability results immediately
    print("\n[INFO] Vulnerability Results:")
    print(json.dumps(vulnerabilities, indent=4))
    return vulnerabilities

def monitor_traffic(interface: str):
    """
    Use Scapy to monitor real-time network traffic on the specified interface.
    Prints the source and destination IP addresses from the captured packets.
    """
    def packet_callback(packet):
        if packet.haslayer(IP):
            print(f"[Traffic] {packet[IP].src} -> {packet[IP].dst}")
    
    print(f"[INFO] Monitoring traffic on interface '{interface}'. Press Ctrl+C to stop.")
    try:
        sniff(iface=interface, prn=packet_callback, store=False)
    except Exception as e:
        print(f"[ERROR] Unable to monitor traffic on interface '{interface}': {e}")

def write_results(results: dict, outfile: str = "scan_results.json"):
    """
    Write the scan and vulnerability results to a JSON file.
    """
    try:
        with open(outfile, "w") as f:
            json.dump(results, f, indent=4)
        print(f"[INFO] Results successfully saved to '{outfile}'.")
    except Exception as e:
        print(f"[ERROR] Could not write results to file: {e}")

def main():
    print("=== Network Vulnerability Scanner ===\n")
    
    check_virtualenv()
    
    target = input("Enter target IP or hostname: ").strip()
    if not validate_target(target):
        print("[ERROR] Invalid target. Exiting.")
        return
    
    # Perform network scanning
    devices = scan_network(target)
    if not devices:
        print("[INFO] No devices or open ports detected. Exiting.")
        return
    
    # Check for vulnerabilities
    vulnerabilities = check_vulnerabilities(devices)
    
    # Consolidate and write-out final results
    results = {
        "timestamp": datetime.now().isoformat(),
        "target": target,
        "devices": devices,
        "vulnerabilities": vulnerabilities
    }
    write_results(results)
    
    # Optionally monitor real-time network traffic
    monitor_opt = input("\nDo you want to monitor network traffic in real time? (y/n): ").strip().lower()
    if monitor_opt == "y":
        interface = input("Enter the network interface to monitor (e.g., eth0): ").strip()
        monitor_traffic(interface)
    else:
        print("[INFO] Scan complete. Stay secure!")

if __name__ == "__main__":
    main()
